# design
利用java实现简单的设计模式   

####单例模式(Singleton)
> 保证一个类有且仅有一个实例，并且提供一个访问它的全局访问点  

####策略模式(Strategy)
>定义了一个算法家族，分别封装起来，让它们之间能够相互替换，此模式让算法进行变化，不会影响到使用算法的客户

####代理模式(Proxy)
>为其他对象提供一种代理以控制对这个对象的访问  

####装饰模式(Decorator)
>动态地给一个对象添加一些额外的职责，相对于生成子类更加灵活   

####工厂方法模式(Factory Method)
>定义一个用于创建对象的接口，让子类决定实例化哪一个类，可以方便的决定创建哪个子类    

####原型模式(Prototype)
>用原型实例指定创建对象的种类，通过拷贝实现创建新的对象    

####外观模式(Facade)
>为子系统中一组接口提供一致的页面，此模式定义了一个高层接口，是这个接口更加容易被子类进行使用   

####模板方法模式(Template Method)
>在父类定义操作算法的骨架，而将具体的实现步骤延迟到子类中。模板方法使得子类可以不改变算法的结构即可重定义改算法的某些特定步骤    

####观察者模式(Observer)
>定义一种多对多的依赖关系，让观察者对象可以同时监听多个主题对象，当主题对象在状态发生变化的时候，会通过所有的观察者对象，使它们能够自动更新自己    

####建造者模式(Builder)
>讲一个复杂的对象的构建与它的表示分离开，使得同样的构建过程可以创建不同的对象    

####抽象工厂模式(Abstract Factory)
>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类    

####适配器模式(Adapter)
>讲一个类的接口转换成客户希望的另一个接口，该模式使得由于接口不兼容的类可以一起工作  

####状态模式(State)
>当一个对象的内在状态改变时允许改变其行为，转换为另外的算法操作或者另外的类    

####备忘录模式(Memento)
>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象内部保存这个状态。这样以后就可以将对象恢复到原先保存的状态   

####组合模式(Composite)
>将对象组合成树形结构以表示整体部分的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性    

####迭代器模式(Iterator)
>提供一种顺序访问一个聚合对象各个元素的方法，而又不暴露改对象的内部表示   

####桥接模式(Bridge)
>将抽象对象与它的实现部分分离，使它们都可以独立地变化

####命令模式(Command)
>将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志以及支持可撤销的操作

####职责链模式(Chain of Responsibility)   
>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一个链条，一直沿着这个链条进行传递，知道有一个对象处理它为止

####中介者模式(Mediator)
>用一个中介对象来封装一系列的对象交互，中介者使个对象不需要显式的相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互

####解释器模式(Interpreter)
>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子

####访问者模式(Visitor)
>表示一个作用于某个对象结构中的个元素的操作，它使你可以不改变各元素的类的前提下定义作用于这些元素的新操作

###不管用什么样的设计模式，都遵守了一下的设计原则

单一职责原则(SRP)，就是一个类而言，只做一件事

开放封闭原则(OCP)，软件实体（类、模块、函数等）提供扩展权，不应该提供随意修改的权利

依赖倒转原则(DIP)，高层模块哦不应该依赖底层模块，两个都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象

里氏代替原则(LSP)，子类型必须能够替换掉它们的父类型

迪米特原则(LoD)，如果两个类不必要彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法的话，可以通过第三个者转发这个调用

合成/聚合复用原则(CARP)，尽量使用合成/聚合,尽量不要使用类继承